package za.ac.salt.pipt.common;import java.util.Calendar;/** * This is a class of static methods for formatting numbers. */public class Format{	/**	 * The family of digits for numbers up to "base 36".	 */	 	private static final String digits = "0123456789abcdefghijklmnopqrstuvwxyz";		/**	 * Formats the given signed integer	 * right-justified in <code>m</code>-character string.	 * The usage ifmt(-7, 6, 2) would produce the string "  -111".	 * Both n and m will be violated as needed to handle the number.	 *	 * @param ival the number to be formatted.	 * @param m the total length of the returned string.	 * @param base the number base (radix) to use in generating digits.	 */		public static String ifmt(long ival, int m, int base)	{		// buffer for holding digits; we assume none will be longer than 128 digits.		char cbuf[] = new char[128];				// the number of characters in the string		int nbuf = 0;				// cache the sign and work with positive numbers		boolean isNegative = false;		if (ival < 0) {			isNegative = true;			ival = Math.abs(ival);		}				// now build up the number in reverse order		boolean done = false;		while (!done) {			cbuf[nbuf++] = digits.charAt((int)(ival % base));			ival /= base;			if (ival == 0) {				done = true;			}		}				// apply the sign if negative		if (isNegative) {			cbuf[nbuf++] = '-';		}				// blank it out to m characters		while (nbuf < m) {			cbuf[nbuf++] = ' ';		}				// now reverse the digits for the final number		StringBuffer s = new StringBuffer();		while (nbuf > 0) {			s.append(cbuf[--nbuf]);		}					return(s.toString());	}		/**	 * Formats the given signed integer in base 10.	 *	 * @see Format#ifmt(long, int, int).	 */		public static String ifmt(long ival, int m)	{		return(ifmt(ival, m, 10));	}		/**	 * Formats the given signed integer in base 10.	 *	 * @see Format#ifmt(long, int, int).	 */		public static String ifmt(long ival)	{		return(ifmt(ival, 0, 10));	}		/**	 * Formats the given integer with <code>n</code> digits	 * right-justified in <code>m</code>-character string.	 * The usage ufmt(7, 10, 8, '0', 2) would produce the string "  00000111".	 * Both n and m will be violated as needed to handle the number.	 *	 * @param ival the number to be formatted.	 * @param m the total length of the returned string.	 * @param n the number of digits in the number.	 * @param fill the character used to left-pad the number.	 * @param base the radix (binary is 2, octal 8, decimal 16, hex 16).	 */		public static String ufmt(long ival, int m, int n, char fill, int base)	{		// ensure proper inputs		ival = Math.abs(ival);		base = Math.max(base, 2);		base = Math.min(base, 36);				// buffer for holding digits; we assume none will be longer than 128 digits.		char cbuf[] = new char[128];				// the number of characters in the string		int nbuf = 0;				// now build up the number in reverse order		boolean done = false;		while (!done) {			cbuf[nbuf++] = digits.charAt((int)(ival % base));			ival /= base;			if (ival == 0) {				done = true;			}		}				// fill it out to "n" digits with the provided fill character		while (nbuf < n) {			cbuf[nbuf++] = fill;		}				// blank it out to m characters		while (nbuf < m) {			cbuf[nbuf++] = ' ';		}				// now reverse the digits for the final number		StringBuffer s = new StringBuffer();		while (nbuf > 0) {			s.append(cbuf[--nbuf]);		}					return(s.toString());	}		/**	 * Formats the given unsigned integer in base 2.	 *	 * @see Format#ufmt(long, int, int, char, int).	 */		public static String bfmt(long ival, int m, int n)	{		return(ufmt(ival, m, n, '0', 2));	}		/**	 * Formats the given unsigned integer in base 2.	 *	 * @see Format#ufmt(long, int, int, char, int).	 */		public static String bfmt(long ival, int n)	{		return(ufmt(ival, 0, n, '0', 2));	}		/**	 * Formats the given unsigned integer in base 2.	 *	 * @see Format#ufmt(long, int, int, char, int).	 */		public static String bfmt(long ival)	{		return(ufmt(ival, 0, 32, '0', 2));	}		/**	 * Formats the given unsigned integer in base 8.	 *	 * @see Format#ufmt(long, int, int, char, int).	 */		public static String ofmt(long ival, int m, int n)	{		return(ufmt(ival, m, n, '0', 8));	}		/**	 * Formats the given unsigned integer in base 8.	 *	 * @see Format#ufmt(long, int, int, char, int).	 */		public static String ofmt(long ival, int n)	{		return(ufmt(ival, 0, n, '0', 8));	}		/**	 * Formats the given unsigned integer in base 8.	 *	 * @see Format#ufmt(long, int, int, char, int).	 */		public static String ofmt(long ival)	{		return(ufmt(ival, 0, 12, '0', 8));	}		/**	 * Formats the given unsigned integer in base 16.	 *	 * @see Format#ufmt(long, int, int, char, int).	 */		public static String xfmt(long ival, int m, int n)	{		return(ufmt(ival, m, n, '0', 16));	}		/**	 * Formats the given unsigned integer in base 16.	 * Prepends "0x".	 *	 * @see #ufmt(long, int, int, char, int).	 */		public static String xfmt(long ival, int n)	{		return("0x"+ufmt(ival, 0, n, '0', 16));	}		/**	 * Formats the given integer in base 16.	 * Prepends "0x".	 *	 * @see #ufmt(long, int, int, char, int).	 */		public static String xfmt(long ival)	{		return("0x"+ufmt(ival, 0, 8, '0', 16));	}	    /**     * Formats the given byte value as a 2-digit hex number,     * in the range 0x00 - 0xff.     * Prepends "0x".     *     * @see Format#ufmt(long, int, int, char, int).     */    public static String xfmt(byte bval)    {		int ival = bval & 0xff;		return("0x"+ufmt(ival, 0, 2, '0', 16));    }	 	/**	 * Formats a double into an m-character string	 * with <code>n</code> digits behind the decimal point.	 * <code>m</code> will be violated as needed to handle the number.	 * Use m=0 to eliminate left-padding.	 *	 * @param fval the value to be formatted.	 * @param m the length of the returned string.	 * @param n the number of digits behind the decimal point.	 * @param fill the character used to left-fill the returned string.	 */	  	public static String ffmt(double fval, int m, int n, char fill)	{		StringBuffer s = new StringBuffer(2*m);				// handle the sign		if (fval < 0) {			s.append('-');	 		fval = Math.abs(fval);		}				// round it to the right precision		double fiddle = Math.pow(10, -n) / 2;		fval += fiddle;				// isolate the whole part		int ival = (int)Math.abs(fval);	 		 	if (n > 0) {	 		s.append(ifmt(ival));	// the 1 is for the decimal point	 		// append the decimal point	 		s.append('.');	 			 		// append the fractional part to the desired precision			while (n-- > 0) {				fval -= ival;				fval *= 10;				ival = (int)fval;				s.append(ival);			}		} else {			s.append(ival);		}			 		 	// prepend fill if needed	 	while (s.length() < m) {	 		s.insert(0, fill);	 	}	 					return(s.toString());	}		/**	 * Formats a double in an m.n format.	 *	 * @see Format#ffmt(double, int, int, char)	 */	  	public static String ffmt(double fval, int m, int n)	{		return(ffmt(fval, m, n, ' '));	}		/**	 * Formats a double with <code>n</code> digits behind the decimal point.	 *	 * @see Format#ffmt(double, int, int, char)	 */	 	public static String ffmt(double fval, int n)	{		return(ffmt(fval, 0, n, ' '));	}		/**	 * Formats a double "nicely".	 * Some numbers, say 1.3, will be formatted by Java as 1.299999999.	 * We would really like this to be formatted as 1.3.	 * We accomplish this seemingly magical feat	 * by perturbing the number away from zero by a very small amount,	 * then keep only the 1st <code>n</code> digits,	 * then dropping trailing zeroes.	 * <p>	 * We could do this right by doing our own implementation of FloatingDecimal,	 * but we're too tired to do that.	 * We'll let FloatingDecimal do all its hard work,	 * and then we'll fix up the output on the cheap.	 */	 	public static String toString(double dval, int n)	{		double epsilon = Math.pow(10, -n) / 2;	// the small perturbation.		//System.out.println("Format.toString: epsilon: " + epsilon);				// perturb the value away from zero		if (dval > 0) {			dval += epsilon;		} else if (dval < 0) {			dval -= epsilon;		}				// turn it into a string		String s = new Double(dval).toString();		//System.out.println("Format.toString: s: " + s);				// keep the leading n characters		n = Math.min(n, s.length());		char cbuf[] = new char[n];		s.getChars(0, n, cbuf, 0);				// find the rightmost non-zero		while ((n > 1) && (cbuf[n-1] == '0')) {			n--;		}				// remove a dangling decimal point		if (cbuf[n-1] == '.') {			n--;		}				// reform the string		StringBuffer sbuf = new StringBuffer();		sbuf.append(cbuf, 0, n);		//System.out.println("Format.toString: sbuf: " + sbuf);				return(sbuf.toString());	}		/**	 * Snaps a double to the next value	 * in a grid of nicely spaced values.	 * <p>	 * Situations can arise where one wants the "nice" value	 * closest to some given trial value.	 * For example, suppose you have a chart 105 pixels wide,	 * and you want to place, say, about 6 tick marks on it.	 * The trial tick spacing is 105/6 = 17.6,	 * which would produce tick labels like 17.6, 35.2, 52.8.	 * Ugly.	 * How much better it would be to place them every 20 pixels,	 * for labels like 20, 40, 60.	 * <p>	 * We want to handle any floating point number,	 * so we're looking for somewhat equal spacing in log space.	 * We choose grid lines at values equal to +/-2^n*10^m,	 * where n and m are integers.	 * <p>	 * We also want to be careful about the situation in which	 * we are handed a value that is already nice.	 * We want to be sure and return that value,	 * not the next higher one.	 * We handle this by perturbing the given value very slightly toward zero,	 * and then letting the algorithm go ahead and find the next higher nice value	 * (which should be the one given).	 * <p>	 * Negative numbers are handled like positive ones;	 * the next "higher" value is farther from zero than the given one.	 * Numbers are carried away from zero to the next grid point.	 */		public static double makeNice(double d)	{		//System.out.println("Format.makeNice: d: " + d);				// cache the sign		int sign = 1;		if (d < 0) {			sign = -1;			d = Math.abs(d);		}				// perturb toward zero		d *= 0.99;		//System.out.println("Format.makeNice: d: " + d);				// find the next lower power of 10		int m = (int)(Math.log(d)/Math.log(10));		if (m < 0) m = m-1;		//System.out.println("Format.makeNice: m: " + m);				// reduce the value by this power of 10		d /= Math.pow(10, m);		//System.out.println("Format.makeNice: d: " + d);				// find the next higher power of 2		//int n = (int)(Math.log(d)/Math.log(2)) + 1;		int n = (int)(Math.log(d)/Math.log(2));		//System.out.println("Format.makeNice: n: " + n);				// now reconstruct the value		d = Math.pow(2, n) * Math.pow(10, m);		//System.out.println("Format.makeNice: d: " + d);				// apply the sign		d *= sign;		//System.out.println("Format.makeNice: d: " + d);				return(d);	}        /**     * Produces a timestamp string for use in file names.     * The string will look like "prefix.YYYYMMDD.hhmmss.suffix".     * The time is the current system time.     */		public static String fileName(String prefix, String suffix)	{		Calendar now = Calendar.getInstance();				StringBuffer fname = new StringBuffer();				fname.append(prefix);		fname.append('.');		fname.append(now.get(Calendar.YEAR));		fname.append(ufmt(now.get(Calendar.MONTH)+1, 0, 2, '0', 10));		fname.append(ufmt(now.get(Calendar.DAY_OF_MONTH), 0, 2, '0', 10));		fname.append(".");		fname.append(ufmt(now.get(Calendar.HOUR_OF_DAY), 0, 2, '0', 10));		fname.append(ufmt(now.get(Calendar.MINUTE), 0, 2, '0', 10));		fname.append(ufmt(now.get(Calendar.SECOND), 0, 2, '0', 10));		fname.append(".");		fname.append(suffix);				return(fname.toString());	}		/**     * A main class for testing this object.     */		public static void main(String args[])	{		Double d;		d = new Double(2.0);		System.out.println(d.toString());		d = new Double(2.0 + Double.MIN_VALUE);		System.out.println(d.toString());		d = new Double(2.0 - Double.MIN_VALUE);		System.out.println(d.toString());				for (int i = -100; i <= 100; i += 5) {			System.out.println("i: " + i);			System.out.println("ifmt:" + Format.ifmt(i, 16, 2));			System.out.println("ifmt:" + Format.ifmt(i, 16, 8));			System.out.println("ifmt:" + Format.ifmt(i, 16, 10));			System.out.println("ifmt:" + Format.ifmt(i, 16, 16));			System.out.println("ifmt:" + Format.ifmt(i, 16, 36));			double dval = i / 100.0;			System.out.println("toString:" + dval + " --> " + Format.toString(dval, 6));		}				for (int i = 0; i <= 100; i += 5) {			System.out.println("i: " + i);			System.out.println("ufmt:" + Format.ufmt(i, 16, 8, '?', 2));			System.out.println("ufmt:" + Format.ufmt(i, 16, 8, '?', 8));			System.out.println("ufmt:" + Format.ufmt(i, 16, 8, '?', 10));			System.out.println("ufmt:" + Format.ufmt(i, 16, 8, '?', 16));			System.out.println("ufmt:" + Format.ufmt(i, 16, 8, '?', 36));			double dval = i / 100.0;			System.out.println("toString:" + dval + " --> " + Format.toString(dval, 6));		}		for (int i = -10; i <= 10; i++) {			System.out.println("i: " + i);			System.out.println("ffmt:" + Format.ffmt(i*Math.E, 10, 3));		}		System.out.println("ffmt:" + Format.ffmt(Math.E, 32, 16));		System.out.println("ffmt:" + Format.ffmt(Math.PI, 32, 16));		String s = Format.ffmt(Math.PI, 6, 3);		System.out.println("ffmt:" + s);		StringBuffer sbuf = new StringBuffer();		sbuf.append(s);		System.out.println("sbuf:" + sbuf.toString());		System.out.println();		for (int i = -10; i < 10; i++) {			System.out.println("makeNice: i: " + i + " nice: " + Format.makeNice(i));		}	}}